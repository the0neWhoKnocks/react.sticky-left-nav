{"version":3,"sources":["../node_modules/stickyfilljs/dist/stickyfill.js"],"names":["window","document","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","testNode","seppuku","isWindowDefined","getComputedStyle","createElement","some","prefix","style","position","e","isInitialized","shadowRootExists","ShadowRoot","scroll","top","left","stickies","extend","targetObj","sourceObject","hasOwnProperty","parseNumeric","val","parseFloat","getDocOffsetTop","node","docOffsetTop","offsetTop","offsetParent","Sticky","instance","TypeError","_classCallCheck","this","HTMLElement","Error","sticky","_node","_stickyMode","_active","push","refresh","value","_removed","_deactivate","nodeComputedStyle","nodeComputedProps","display","marginTop","marginBottom","marginLeft","marginRight","cssFloat","isNaN","originalPosition","referenceNode","parentNode","host","nodeWinOffset","getBoundingClientRect","parentWinOffset","parentComputedStyle","_parent","styles","offsetHeight","_offsetToWindow","right","documentElement","clientWidth","_offsetToParent","borderTopWidth","borderLeftWidth","borderRightWidth","_styles","bottom","width","nodeTopValue","_limits","start","pageYOffset","end","borderBottomWidth","parentPosition","_recalcPosition","clone","_clone","height","padding","border","borderSpacing","fontSize","insertBefore","stickyMode","Math","abs","_this","removeChild","_this2","index","splice","Stickyfill","forceSticky","init","refreshAll","addOne","add","nodeList","addedStickies","_loop","forEach","removeOne","remove","_loop2","removeAll","checkScroll","addEventListener","fastCheckTimer","docHiddenKey","visibilityChangeEventName","startFastCheckTimer","clearInterval","pageXOffset","setInterval","_fastCheck","module","exports"],"mappings":"2EAOA,SAAAA,EAAAC,GACA,aAOA,IAAAC,EAAA,WACA,SAAAC,EAAAC,EAAAC,GACA,QAAAC,EAAA,EAAqBA,EAAAD,EAAAE,OAAkBD,IAAA,CACvC,IAAAE,EAAAH,EAAAC,GACAE,EAAAC,WAAAD,EAAAC,aAAA,EACAD,EAAAE,cAAA,EACA,UAAAF,MAAAG,UAAA,GACAC,OAAAC,eAAAT,EAAAI,EAAAM,IAAAN,IAIA,gBAAAO,EAAAC,EAAAC,GAGA,OAFAD,GAAAb,EAAAY,EAAAG,UAAAF,GACAC,GAAAd,EAAAY,EAAAE,GACAF,GAdA,GAwBA,IAMAI,EANAC,GAAA,EACAC,EAAA,qBAAArB,EAEAqB,GAAArB,EAAAsB,kBAGAH,EAAAlB,EAAAsB,cAAA,OACA,+BAAAC,KAAA,SAAAC,GACA,IACAN,EAAAO,MAAAC,SAAAF,EAAA,SACW,MAAAG,IAEX,UAAAT,EAAAO,MAAAC,aACSP,GAAA,IAVTA,GAAA,EAiBA,IAAAS,GAAA,EAEAC,EAAA,qBAAAC,WAEAC,EAAA,CACAC,IAAA,KACAC,KAAA,MAGAC,EAAA,GAKA,SAAAC,EAAAC,EAAAC,GACA,QAAAxB,KAAAwB,EACAA,EAAAC,eAAAzB,KACAuB,EAAAvB,GAAAwB,EAAAxB,IAKA,SAAA0B,EAAAC,GACA,OAAAC,WAAAD,IAAA,EAGA,SAAAE,EAAAC,GAGA,IAFA,IAAAC,EAAA,EAEAD,GACAC,GAAAD,EAAAE,UACAF,IAAAG,aAGA,OAAAF,EAOA,IAAAG,EAAA,WACA,SAAAA,EAAAJ,GAGA,GAvEA,SAAAK,EAAAlC,GACA,KAAAkC,aAAAlC,GACA,UAAAmC,UAAA,qCAmEAC,CAAAC,KAAAJ,KAEAJ,aAAAS,aAAA,UAAAC,MAAA,sCACA,GAAAnB,EAAAX,KAAA,SAAA+B,GACA,OAAAA,EAAAC,QAAAZ,IACO,UAAAU,MAAA,8CACPF,KAAAI,MAAAZ,EACAQ,KAAAK,YAAA,KACAL,KAAAM,SAAA,EACAvB,EAAAwB,KAAAP,MACAA,KAAAQ,UA8NA,OA3NA1D,EAAA8C,EAAA,EACAlC,IAAA,UACA+C,MAAA,WACA,IAAAzC,IAAAgC,KAAAU,SAAA,CACAV,KAAAM,SAAAN,KAAAW,cACA,IAAAnB,EAAAQ,KAAAI,MAKAQ,EAAA1C,iBAAAsB,GACAqB,EAAA,CACAtC,SAAAqC,EAAArC,SACAM,IAAA+B,EAAA/B,IACAiC,QAAAF,EAAAE,QACAC,UAAAH,EAAAG,UACAC,aAAAJ,EAAAI,aACAC,WAAAL,EAAAK,WACAC,YAAAN,EAAAM,YACAC,SAAAP,EAAAO,UAMA,IAAAC,MAAA9B,WAAAuB,EAAAhC,OAAA,cAAAgC,EAAAC,SAAA,QAAAD,EAAAC,QAAA,CACAd,KAAAM,SAAA,EAOA,IAAAe,EAAA7B,EAAAlB,MAAAC,SACA,UAAAqC,EAAArC,UAAA,kBAAAqC,EAAArC,WAAAiB,EAAAlB,MAAAC,SAAA,UAKA,IAAA+C,EAAA9B,EAAA+B,WACAA,EAAA7C,GAAA4C,aAAA3C,WAAA2C,EAAAE,KAAAF,EACAG,EAAAjC,EAAAkC,wBACAC,EAAAJ,EAAAG,wBACAE,EAAA1D,iBAAAqD,GACAvB,KAAA6B,QAAA,CACArC,KAAA+B,EACAO,OAAA,CACAvD,SAAAgD,EAAAjD,MAAAC,UAEAwD,aAAAR,EAAAQ,cAEA/B,KAAAgC,gBAAA,CACAlD,KAAA2C,EAAA3C,KACAmD,MAAApF,EAAAqF,gBAAAC,YAAAV,EAAAQ,OAEAjC,KAAAoC,gBAAA,CACAvD,IAAA4C,EAAA5C,IAAA8C,EAAA9C,IAAAO,EAAAwC,EAAAS,gBACAvD,KAAA2C,EAAA3C,KAAA6C,EAAA7C,KAAAM,EAAAwC,EAAAU,iBACAL,OAAAR,EAAAQ,MAAAN,EAAAM,MAAA7C,EAAAwC,EAAAW,mBAEAvC,KAAAwC,QAAA,CACAjE,SAAA8C,EACAxC,IAAAW,EAAAlB,MAAAO,IACA4D,OAAAjD,EAAAlB,MAAAmE,OACA3D,KAAAU,EAAAlB,MAAAQ,KACAmD,MAAAzC,EAAAlB,MAAA2D,MACAS,MAAAlD,EAAAlB,MAAAoE,MACA3B,UAAAvB,EAAAlB,MAAAyC,UACAE,WAAAzB,EAAAlB,MAAA2C,WACAC,YAAA1B,EAAAlB,MAAA4C,aAEA,IAAAyB,EAAAvD,EAAAyB,EAAAhC,KACAmB,KAAA4C,QAAA,CACAC,MAAApB,EAAA5C,IAAAjC,EAAAkG,YAAAH,EACAI,IAAApB,EAAA9C,IAAAjC,EAAAkG,YAAAvB,EAAAQ,aAAA3C,EAAAwC,EAAAoB,mBAAAxD,EAAAuC,aAAAY,EAAAvD,EAAAyB,EAAAG,eAMA,IAAAiC,EAAArB,EAAArD,SAEA,YAAA0E,GAAA,YAAAA,IACA1B,EAAAjD,MAAAC,SAAA,YAQAyB,KAAAkD,kBAMA,IAAAC,EAAAnD,KAAAoD,OAAA,GACAD,EAAA3D,KAAA3C,EAAAsB,cAAA,OAEAa,EAAAmE,EAAA3D,KAAAlB,MAAA,CACAoE,MAAAjB,EAAAQ,MAAAR,EAAA3C,KAAA,KACAuE,OAAA5B,EAAAgB,OAAAhB,EAAA5C,IAAA,KACAkC,UAAAF,EAAAE,UACAC,aAAAH,EAAAG,aACAC,WAAAJ,EAAAI,WACAC,YAAAL,EAAAK,YACAC,SAAAN,EAAAM,SACAmC,QAAA,EACAC,OAAA,EACAC,cAAA,EACAC,SAAA,MACAlF,SAAA,WAEA+C,EAAAoC,aAAAP,EAAA3D,QACA2D,EAAA1D,aAAAF,EAAA4D,EAAA3D,UAEK,CACL9B,IAAA,kBACA+C,MAAA,WACA,GAAAT,KAAAM,UAAAN,KAAAU,SAAA,CACA,IAAAiD,EAAA/E,EAAAC,KAAAmB,KAAA4C,QAAAC,MAAA,QAAAjE,EAAAC,KAAAmB,KAAA4C,QAAAG,IAAA,eACA,GAAA/C,KAAAK,aAAAsD,EAAA,CAEA,OAAAA,GACA,YACA3E,EAAAgB,KAAAI,MAAA9B,MAAA,CACAC,SAAA,WACAO,KAAAkB,KAAAoC,gBAAAtD,KAAA,KACAmD,MAAAjC,KAAAoC,gBAAAH,MAAA,KACApD,IAAAmB,KAAAoC,gBAAAvD,IAAA,KACA4D,OAAA,OACAC,MAAA,OACAzB,WAAA,EACAC,YAAA,EACAH,UAAA,IAEA,MAEA,aACA/B,EAAAgB,KAAAI,MAAA9B,MAAA,CACAC,SAAA,QACAO,KAAAkB,KAAAgC,gBAAAlD,KAAA,KACAmD,MAAAjC,KAAAgC,gBAAAC,MAAA,KACApD,IAAAmB,KAAAwC,QAAA3D,IACA4D,OAAA,OACAC,MAAA,OACAzB,WAAA,EACAC,YAAA,EACAH,UAAA,IAEA,MAEA,UACA/B,EAAAgB,KAAAI,MAAA9B,MAAA,CACAC,SAAA,WACAO,KAAAkB,KAAAoC,gBAAAtD,KAAA,KACAmD,MAAAjC,KAAAoC,gBAAAH,MAAA,KACApD,IAAA,OACA4D,OAAA,EACAC,MAAA,OACAzB,WAAA,EACAC,YAAA,IAKAlB,KAAAK,YAAAsD,MAEK,CACLjG,IAAA,aACA+C,MAAA,WACAT,KAAAM,UAAAN,KAAAU,WACAkD,KAAAC,IAAAtE,EAAAS,KAAAoD,OAAA5D,MAAAQ,KAAAoD,OAAA3D,cAAA,GAAAmE,KAAAC,IAAA7D,KAAA6B,QAAArC,KAAAuC,aAAA/B,KAAA6B,QAAAE,cAAA,IAAA/B,KAAAQ,YAEK,CACL9C,IAAA,cACA+C,MAAA,WACA,IAAAqD,EAAA9D,KAEAA,KAAAM,UAAAN,KAAAU,WAEAV,KAAAoD,OAAA5D,KAAA+B,WAAAwC,YAAA/D,KAAAoD,OAAA5D,aAEAQ,KAAAoD,OACApE,EAAAgB,KAAAI,MAAA9B,MAAA0B,KAAAwC,gBACAxC,KAAAwC,QAGAzD,EAAAX,KAAA,SAAA+B,GACA,OAAAA,IAAA2D,GAAA3D,EAAA0B,SAAA1B,EAAA0B,QAAArC,OAAAsE,EAAAjC,QAAArC,QAEAR,EAAAgB,KAAA6B,QAAArC,KAAAlB,MAAA0B,KAAA6B,QAAAC,eAGA9B,KAAA6B,QACA7B,KAAAK,YAAA,KACAL,KAAAM,SAAA,SACAN,KAAAgC,uBACAhC,KAAAoC,uBACApC,KAAA4C,WAEK,CACLlF,IAAA,SACA+C,MAAA,WACA,IAAAuD,EAAAhE,KAEAA,KAAAW,cAEA5B,EAAAX,KAAA,SAAA+B,EAAA8D,GACA,GAAA9D,EAAAC,QAAA4D,EAAA5D,MAEA,OADArB,EAAAmF,OAAAD,EAAA,IACA,IAGAjE,KAAAU,UAAA,MAIAd,EA1OA,GAiPAuE,EAAA,CACApF,WACAa,SACAwE,YAAA,WACApG,GAAA,EACAqG,IACArE,KAAAsE,cAEAC,OAAA,SAAA/E,GAEA,KAAAA,aAAAS,aAAA,CAGA,IAAAT,EAAArC,SAAAqC,EAAA,GAAmD,OAAnDA,IAAA,GAKA,QAAAtC,EAAA,EAAqBA,EAAA6B,EAAA5B,OAAqBD,IAC1C,GAAA6B,EAAA7B,GAAAkD,QAAAZ,EAAA,OAAAT,EAAA7B,GAIA,WAAA0C,EAAAJ,IAEAgF,IAAA,SAAAC,GAIA,GAFAA,aAAAxE,cAAAwE,EAAA,CAAAA,IAEAA,EAAAtH,OAAA,CAyBA,IAvBA,IAAAuH,EAAA,GAEAC,EAAA,SAAAzH,GACA,IAAAsC,EAAAiF,EAAAvH,GAGA,OAAAsC,aAAAS,YAOAlB,EAAAX,KAAA,SAAA+B,GACA,GAAAA,EAAAC,QAAAZ,EAEA,OADAkF,EAAAnE,KAAAJ,IACA,IAES,gBAETuE,EAAAnE,KAAA,IAAAX,EAAAJ,KAbAkF,EAAAnE,UAAA,GACA,aAeArD,EAAA,EAAqBA,EAAAuH,EAAAtH,OAAqBD,IAC1CyH,EAAAzH,GAKA,OAAAwH,IAEAJ,WAAA,WACAvF,EAAA6F,QAAA,SAAAzE,GACA,OAAAA,EAAAK,aAGAqE,UAAA,SAAArF,GAEA,KAAAA,aAAAS,aAAA,CAGA,IAAAT,EAAArC,SAAAqC,EAAA,GAAmD,OAAnDA,IAAA,GAIAT,EAAAX,KAAA,SAAA+B,GACA,GAAAA,EAAAC,QAAAZ,EAEA,OADAW,EAAA2E,UACA,KAIAA,OAAA,SAAAL,GAIA,GAFAA,aAAAxE,cAAAwE,EAAA,CAAAA,IAEAA,EAAAtH,OAYA,IAVA,IAAA4H,EAAA,SAAA7H,GACA,IAAAsC,EAAAiF,EAAAvH,GACA6B,EAAAX,KAAA,SAAA+B,GACA,GAAAA,EAAAC,QAAAZ,EAEA,OADAW,EAAA2E,UACA,KAKA5H,EAAA,EAAqBA,EAAAuH,EAAAtH,OAAqBD,IAC1C6H,EAAA7H,IAGA8H,UAAA,WACA,KAAAjG,EAAA5B,QACA4B,EAAA,GAAA+F,WAQA,SAAAT,IACA,IAAA5F,EAAA,CAIAA,GAAA,EAiBAwG,IACArI,EAAAsI,iBAAA,SAAAD,GAEArI,EAAAsI,iBAAA,SAAAf,EAAAG,YACA1H,EAAAsI,iBAAA,oBAAAf,EAAAG,YAEA,IAAAa,OAAA,EAcAC,OAAA,EACAC,OAAA,EAEA,WAAAxI,GACAuI,EAAA,SACAC,EAAA,oBACK,iBAAAxI,IACLuI,EAAA,eACAC,EAAA,0BAGAA,GACAxI,EAAAuI,IAAAE,IACAzI,EAAAqI,iBAAAG,EAAA,WACAxI,EAAAuI,GAjBAG,cAAAJ,GAoBAG,OAGKA,IAvDL,SAAAL,IACArI,EAAA4I,aAAA5G,EAAAE,MACAF,EAAAC,IAAAjC,EAAAkG,YACAlE,EAAAE,KAAAlC,EAAA4I,YACArB,EAAAG,cACO1H,EAAAkG,aAAAlE,EAAAC,MACPD,EAAAC,IAAAjC,EAAAkG,YACAlE,EAAAE,KAAAlC,EAAA4I,YAEAzG,EAAA6F,QAAA,SAAAzE,GACA,OAAAA,EAAA+C,qBAaA,SAAAoC,IACAH,EAAAM,YAAA,WACA1G,EAAA6F,QAAA,SAAAzE,GACA,OAAAA,EAAAuF,gBAEO,MA8BP1H,GAAAqG,IAKA,oBAAAsB,KAAAC,QACAD,EAAAC,QAAAzB,EACGlG,IACHrB,EAAAuH,cAxgBA,CA0gBCvH,OAAAC","file":"static/js/polyfill.sticky.82763012.chunk.js","sourcesContent":["/*!\r\n  * Stickyfill – `position: sticky` polyfill\r\n  * v. 2.1.0 | https://github.com/wilddeer/stickyfill\r\n  * MIT License\r\n  */\n;\n\n(function (window, document) {\n  'use strict';\n  /*\r\n   * 1. Check if the browser supports `position: sticky` natively or is too old to run the polyfill.\r\n   *    If either of these is the case set `seppuku` flag. It will be checked later to disable key features\r\n   *    of the polyfill, but the API will remain functional to avoid breaking things.\r\n   */\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var seppuku = false;\n  var isWindowDefined = typeof window !== 'undefined'; // The polyfill can’t function properly without `window` or `window.getComputedStyle`.\n\n  if (!isWindowDefined || !window.getComputedStyle) seppuku = true; // Dont’t get in a way if the browser supports `position: sticky` natively.\n  else {\n      (function () {\n        var testNode = document.createElement('div');\n        if (['', '-webkit-', '-moz-', '-ms-'].some(function (prefix) {\n          try {\n            testNode.style.position = prefix + 'sticky';\n          } catch (e) {}\n\n          return testNode.style.position != '';\n        })) seppuku = true;\n      })();\n    }\n  /*\r\n   * 2. “Global” vars used across the polyfill\r\n   */\n\n  var isInitialized = false; // Check if Shadow Root constructor exists to make further checks simpler\n\n  var shadowRootExists = typeof ShadowRoot !== 'undefined'; // Last saved scroll position\n\n  var scroll = {\n    top: null,\n    left: null\n  }; // Array of created Sticky instances\n\n  var stickies = [];\n  /*\r\n   * 3. Utility functions\r\n   */\n\n  function extend(targetObj, sourceObject) {\n    for (var key in sourceObject) {\n      if (sourceObject.hasOwnProperty(key)) {\n        targetObj[key] = sourceObject[key];\n      }\n    }\n  }\n\n  function parseNumeric(val) {\n    return parseFloat(val) || 0;\n  }\n\n  function getDocOffsetTop(node) {\n    var docOffsetTop = 0;\n\n    while (node) {\n      docOffsetTop += node.offsetTop;\n      node = node.offsetParent;\n    }\n\n    return docOffsetTop;\n  }\n  /*\r\n   * 4. Sticky class\r\n   */\n\n\n  var Sticky = function () {\n    function Sticky(node) {\n      _classCallCheck(this, Sticky);\n\n      if (!(node instanceof HTMLElement)) throw new Error('First argument must be HTMLElement');\n      if (stickies.some(function (sticky) {\n        return sticky._node === node;\n      })) throw new Error('Stickyfill is already applied to this node');\n      this._node = node;\n      this._stickyMode = null;\n      this._active = false;\n      stickies.push(this);\n      this.refresh();\n    }\n\n    _createClass(Sticky, [{\n      key: 'refresh',\n      value: function refresh() {\n        if (seppuku || this._removed) return;\n        if (this._active) this._deactivate();\n        var node = this._node;\n        /*\r\n         * 1. Save node computed props\r\n         */\n\n        var nodeComputedStyle = getComputedStyle(node);\n        var nodeComputedProps = {\n          position: nodeComputedStyle.position,\n          top: nodeComputedStyle.top,\n          display: nodeComputedStyle.display,\n          marginTop: nodeComputedStyle.marginTop,\n          marginBottom: nodeComputedStyle.marginBottom,\n          marginLeft: nodeComputedStyle.marginLeft,\n          marginRight: nodeComputedStyle.marginRight,\n          cssFloat: nodeComputedStyle.cssFloat\n        };\n        /*\r\n         * 2. Check if the node can be activated\r\n         */\n\n        if (isNaN(parseFloat(nodeComputedProps.top)) || nodeComputedProps.display == 'table-cell' || nodeComputedProps.display == 'none') return;\n        this._active = true;\n        /*\r\n         * 3. Check if the current node position is `sticky`. If it is, it means that the browser supports sticky positioning,\r\n         *    but the polyfill was force-enabled. We set the node’s position to `static` before continuing, so that the node\r\n         *    is in it’s initial position when we gather its params.\r\n         */\n\n        var originalPosition = node.style.position;\n        if (nodeComputedStyle.position == 'sticky' || nodeComputedStyle.position == '-webkit-sticky') node.style.position = 'static';\n        /*\r\n         * 4. Get necessary node parameters\r\n         */\n\n        var referenceNode = node.parentNode;\n        var parentNode = shadowRootExists && referenceNode instanceof ShadowRoot ? referenceNode.host : referenceNode;\n        var nodeWinOffset = node.getBoundingClientRect();\n        var parentWinOffset = parentNode.getBoundingClientRect();\n        var parentComputedStyle = getComputedStyle(parentNode);\n        this._parent = {\n          node: parentNode,\n          styles: {\n            position: parentNode.style.position\n          },\n          offsetHeight: parentNode.offsetHeight\n        };\n        this._offsetToWindow = {\n          left: nodeWinOffset.left,\n          right: document.documentElement.clientWidth - nodeWinOffset.right\n        };\n        this._offsetToParent = {\n          top: nodeWinOffset.top - parentWinOffset.top - parseNumeric(parentComputedStyle.borderTopWidth),\n          left: nodeWinOffset.left - parentWinOffset.left - parseNumeric(parentComputedStyle.borderLeftWidth),\n          right: -nodeWinOffset.right + parentWinOffset.right - parseNumeric(parentComputedStyle.borderRightWidth)\n        };\n        this._styles = {\n          position: originalPosition,\n          top: node.style.top,\n          bottom: node.style.bottom,\n          left: node.style.left,\n          right: node.style.right,\n          width: node.style.width,\n          marginTop: node.style.marginTop,\n          marginLeft: node.style.marginLeft,\n          marginRight: node.style.marginRight\n        };\n        var nodeTopValue = parseNumeric(nodeComputedProps.top);\n        this._limits = {\n          start: nodeWinOffset.top + window.pageYOffset - nodeTopValue,\n          end: parentWinOffset.top + window.pageYOffset + parentNode.offsetHeight - parseNumeric(parentComputedStyle.borderBottomWidth) - node.offsetHeight - nodeTopValue - parseNumeric(nodeComputedProps.marginBottom)\n        };\n        /*\r\n         * 5. Ensure that the node will be positioned relatively to the parent node\r\n         */\n\n        var parentPosition = parentComputedStyle.position;\n\n        if (parentPosition != 'absolute' && parentPosition != 'relative') {\n          parentNode.style.position = 'relative';\n        }\n        /*\r\n         * 6. Recalc node position.\r\n         *    It’s important to do this before clone injection to avoid scrolling bug in Chrome.\r\n         */\n\n\n        this._recalcPosition();\n        /*\r\n         * 7. Create a clone\r\n         */\n\n\n        var clone = this._clone = {};\n        clone.node = document.createElement('div'); // Apply styles to the clone\n\n        extend(clone.node.style, {\n          width: nodeWinOffset.right - nodeWinOffset.left + 'px',\n          height: nodeWinOffset.bottom - nodeWinOffset.top + 'px',\n          marginTop: nodeComputedProps.marginTop,\n          marginBottom: nodeComputedProps.marginBottom,\n          marginLeft: nodeComputedProps.marginLeft,\n          marginRight: nodeComputedProps.marginRight,\n          cssFloat: nodeComputedProps.cssFloat,\n          padding: 0,\n          border: 0,\n          borderSpacing: 0,\n          fontSize: '1em',\n          position: 'static'\n        });\n        referenceNode.insertBefore(clone.node, node);\n        clone.docOffsetTop = getDocOffsetTop(clone.node);\n      }\n    }, {\n      key: '_recalcPosition',\n      value: function _recalcPosition() {\n        if (!this._active || this._removed) return;\n        var stickyMode = scroll.top <= this._limits.start ? 'start' : scroll.top >= this._limits.end ? 'end' : 'middle';\n        if (this._stickyMode == stickyMode) return;\n\n        switch (stickyMode) {\n          case 'start':\n            extend(this._node.style, {\n              position: 'absolute',\n              left: this._offsetToParent.left + 'px',\n              right: this._offsetToParent.right + 'px',\n              top: this._offsetToParent.top + 'px',\n              bottom: 'auto',\n              width: 'auto',\n              marginLeft: 0,\n              marginRight: 0,\n              marginTop: 0\n            });\n            break;\n\n          case 'middle':\n            extend(this._node.style, {\n              position: 'fixed',\n              left: this._offsetToWindow.left + 'px',\n              right: this._offsetToWindow.right + 'px',\n              top: this._styles.top,\n              bottom: 'auto',\n              width: 'auto',\n              marginLeft: 0,\n              marginRight: 0,\n              marginTop: 0\n            });\n            break;\n\n          case 'end':\n            extend(this._node.style, {\n              position: 'absolute',\n              left: this._offsetToParent.left + 'px',\n              right: this._offsetToParent.right + 'px',\n              top: 'auto',\n              bottom: 0,\n              width: 'auto',\n              marginLeft: 0,\n              marginRight: 0\n            });\n            break;\n        }\n\n        this._stickyMode = stickyMode;\n      }\n    }, {\n      key: '_fastCheck',\n      value: function _fastCheck() {\n        if (!this._active || this._removed) return;\n        if (Math.abs(getDocOffsetTop(this._clone.node) - this._clone.docOffsetTop) > 1 || Math.abs(this._parent.node.offsetHeight - this._parent.offsetHeight) > 1) this.refresh();\n      }\n    }, {\n      key: '_deactivate',\n      value: function _deactivate() {\n        var _this = this;\n\n        if (!this._active || this._removed) return;\n\n        this._clone.node.parentNode.removeChild(this._clone.node);\n\n        delete this._clone;\n        extend(this._node.style, this._styles);\n        delete this._styles; // Check whether element’s parent node is used by other stickies.\n        // If not, restore parent node’s styles.\n\n        if (!stickies.some(function (sticky) {\n          return sticky !== _this && sticky._parent && sticky._parent.node === _this._parent.node;\n        })) {\n          extend(this._parent.node.style, this._parent.styles);\n        }\n\n        delete this._parent;\n        this._stickyMode = null;\n        this._active = false;\n        delete this._offsetToWindow;\n        delete this._offsetToParent;\n        delete this._limits;\n      }\n    }, {\n      key: 'remove',\n      value: function remove() {\n        var _this2 = this;\n\n        this._deactivate();\n\n        stickies.some(function (sticky, index) {\n          if (sticky._node === _this2._node) {\n            stickies.splice(index, 1);\n            return true;\n          }\n        });\n        this._removed = true;\n      }\n    }]);\n\n    return Sticky;\n  }();\n  /*\r\n   * 5. Stickyfill API\r\n   */\n\n\n  var Stickyfill = {\n    stickies: stickies,\n    Sticky: Sticky,\n    forceSticky: function forceSticky() {\n      seppuku = false;\n      init();\n      this.refreshAll();\n    },\n    addOne: function addOne(node) {\n      // Check whether it’s a node\n      if (!(node instanceof HTMLElement)) {\n        // Maybe it’s a node list of some sort?\n        // Take first node from the list then\n        if (node.length && node[0]) node = node[0];else return;\n      } // Check if Stickyfill is already applied to the node\n      // and return existing sticky\n\n\n      for (var i = 0; i < stickies.length; i++) {\n        if (stickies[i]._node === node) return stickies[i];\n      } // Create and return new sticky\n\n\n      return new Sticky(node);\n    },\n    add: function add(nodeList) {\n      // If it’s a node make an array of one node\n      if (nodeList instanceof HTMLElement) nodeList = [nodeList]; // Check if the argument is an iterable of some sort\n\n      if (!nodeList.length) return; // Add every element as a sticky and return an array of created Sticky instances\n\n      var addedStickies = [];\n\n      var _loop = function _loop(i) {\n        var node = nodeList[i]; // If it’s not an HTMLElement – create an empty element to preserve 1-to-1\n        // correlation with input list\n\n        if (!(node instanceof HTMLElement)) {\n          addedStickies.push(void 0);\n          return 'continue';\n        } // If Stickyfill is already applied to the node\n        // add existing sticky\n\n\n        if (stickies.some(function (sticky) {\n          if (sticky._node === node) {\n            addedStickies.push(sticky);\n            return true;\n          }\n        })) return 'continue'; // Create and add new sticky\n\n        addedStickies.push(new Sticky(node));\n      };\n\n      for (var i = 0; i < nodeList.length; i++) {\n        var _ret2 = _loop(i);\n\n        if (_ret2 === 'continue') continue;\n      }\n\n      return addedStickies;\n    },\n    refreshAll: function refreshAll() {\n      stickies.forEach(function (sticky) {\n        return sticky.refresh();\n      });\n    },\n    removeOne: function removeOne(node) {\n      // Check whether it’s a node\n      if (!(node instanceof HTMLElement)) {\n        // Maybe it’s a node list of some sort?\n        // Take first node from the list then\n        if (node.length && node[0]) node = node[0];else return;\n      } // Remove the stickies bound to the nodes in the list\n\n\n      stickies.some(function (sticky) {\n        if (sticky._node === node) {\n          sticky.remove();\n          return true;\n        }\n      });\n    },\n    remove: function remove(nodeList) {\n      // If it’s a node make an array of one node\n      if (nodeList instanceof HTMLElement) nodeList = [nodeList]; // Check if the argument is an iterable of some sort\n\n      if (!nodeList.length) return; // Remove the stickies bound to the nodes in the list\n\n      var _loop2 = function _loop2(i) {\n        var node = nodeList[i];\n        stickies.some(function (sticky) {\n          if (sticky._node === node) {\n            sticky.remove();\n            return true;\n          }\n        });\n      };\n\n      for (var i = 0; i < nodeList.length; i++) {\n        _loop2(i);\n      }\n    },\n    removeAll: function removeAll() {\n      while (stickies.length) {\n        stickies[0].remove();\n      }\n    }\n  };\n  /*\r\n   * 6. Setup events (unless the polyfill was disabled)\r\n   */\n\n  function init() {\n    if (isInitialized) {\n      return;\n    }\n\n    isInitialized = true; // Watch for scroll position changes and trigger recalc/refresh if needed\n\n    function checkScroll() {\n      if (window.pageXOffset != scroll.left) {\n        scroll.top = window.pageYOffset;\n        scroll.left = window.pageXOffset;\n        Stickyfill.refreshAll();\n      } else if (window.pageYOffset != scroll.top) {\n        scroll.top = window.pageYOffset;\n        scroll.left = window.pageXOffset; // recalc position for all stickies\n\n        stickies.forEach(function (sticky) {\n          return sticky._recalcPosition();\n        });\n      }\n    }\n\n    checkScroll();\n    window.addEventListener('scroll', checkScroll); // Watch for window resizes and device orientation changes and trigger refresh\n\n    window.addEventListener('resize', Stickyfill.refreshAll);\n    window.addEventListener('orientationchange', Stickyfill.refreshAll); //Fast dirty check for layout changes every 500ms\n\n    var fastCheckTimer = void 0;\n\n    function startFastCheckTimer() {\n      fastCheckTimer = setInterval(function () {\n        stickies.forEach(function (sticky) {\n          return sticky._fastCheck();\n        });\n      }, 500);\n    }\n\n    function stopFastCheckTimer() {\n      clearInterval(fastCheckTimer);\n    }\n\n    var docHiddenKey = void 0;\n    var visibilityChangeEventName = void 0;\n\n    if ('hidden' in document) {\n      docHiddenKey = 'hidden';\n      visibilityChangeEventName = 'visibilitychange';\n    } else if ('webkitHidden' in document) {\n      docHiddenKey = 'webkitHidden';\n      visibilityChangeEventName = 'webkitvisibilitychange';\n    }\n\n    if (visibilityChangeEventName) {\n      if (!document[docHiddenKey]) startFastCheckTimer();\n      document.addEventListener(visibilityChangeEventName, function () {\n        if (document[docHiddenKey]) {\n          stopFastCheckTimer();\n        } else {\n          startFastCheckTimer();\n        }\n      });\n    } else startFastCheckTimer();\n  }\n\n  if (!seppuku) init();\n  /*\r\n   * 7. Expose Stickyfill\r\n   */\n\n  if (typeof module != 'undefined' && module.exports) {\n    module.exports = Stickyfill;\n  } else if (isWindowDefined) {\n    window.Stickyfill = Stickyfill;\n  }\n})(window, document);"],"sourceRoot":""}